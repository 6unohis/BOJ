- 상대방보다 더 작은 수 (n + 1) / 2개 가지고 있어야함

- 수 하나하나를 모든 요소와 비교하기에는 시간복잡도가 O(n ^ 2)

- 특정 수를 확인하는 투 포인터같은 느낌으로 가보자

- 배열을 오름차순으로 정렬하고 수 비교

- arr의 처음요소보다 큰 값을 tmp배열에서 찾고, 승부에 사용하는 카드는 버리기때문에 arr와 tmp배열 인덱스를 모두 증가시켜 비교함

- 더 작은 값이 아닌 경우 tmp배열의 값을 더 크게 해야하기 때문에 tmp배열의 인덱스만 증가

```c
while(left < n && right < n){
    if(arr[left] < tmp[right]>){
        cnt++;
        left++;
        right++;
    } else right++;
}
```
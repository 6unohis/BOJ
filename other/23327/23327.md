첫 번째 생각 -> 단순 조합

```c
for(i = l; i < r; i++){
    for(j = l + 1; j <= r; j++) ans += arr[i] * arr[j];
}
```

> 시간도 오래걸리고, Q번 하는 과정에서 시간이 훨씬 커짐

두 번째 생각 -> 누적합 사용

- 예제에서 5 1 2 3 2일 때, 디비전마다의 누적합은 0 5 17 41 63 => 증가폭은 i번째 수를 기준으로, i - 1까지의 누적합 * arr[i]

```c
// sum -> 누적합 배열
for(i = l; i <= r; i++){
    ans += sum[i - 1] * arr[i];
}
```

> 첫 번째보다는 줄어들지만, Q번 하는 과정에서 시간 초과 발생

 결론(앞으로 나오는 숫자는 인덱스)

 - 총 재미 = (2 + 3 + 4 + 5) * 1 + (3 + 4 + 5) * 2 + (4 + 5) * 3 + (5) * 4

 - = 5 * (1 + 2 + 3 + 4) + 4 * (1 + 2 + 3) + 3 * (1 + 2) + 2 * 1로 표현할 수 있음(5, 4, 3, 2 순서로 누적)

 - 만약 left : 3 , right : 5라면 구해야 하는 값은 3 * (4 + 5) + 4 * 5 = 5 * (3 + 4) + 4 * 3 = 5까지의 누적 - 3까지의 누적 - (5 * (1 + 2) + 4 *(1 + 2))

 - 즉, 나타내면 fun[right] - fun[left - 1] - ((1 ~ left - 1까지의 누적합) * (left + 1 ~ right까지의 누적합))

 ```c
 answer = fun[r] - fun[l - 1] - sum[l -1] * (sum[r] - sum[l - 1]);
 ```